/******************************************************************************
* Copyright Â© 2005-2012 by Pike Aerospace Research Corporation
* All Rights Reserved
*
*   This file is part of CARIBOU RTOS
*
*   CARIBOU RTOS is free software: you can redistribute it and/or modify
*   it under the terms of the Beerware License Version 43.
*
* ----------------------------------------------------------------------------
* "THE BEER-WARE LICENSE" (Revision 43):
* <mike@pikeaero.com> wrote this file. As long as you retain this notice you
* can do whatever you want with this stuff. If we meet some day, and you think
* this stuff is worth it, you can buy me a beer in return ~ Mike Sharkey
* ----------------------------------------------------------------------------
******************************************************************************/
#ifndef CARIBOUTIMER_H
#define CARIBOUTIMER_H

#include <caribou/kernel/types.h>
#include <chip/chip.h>

#ifdef __cplusplus
extern "C"
{
#endif

/** 
 * @brief If the CARIBOU_TIMER_F_DYNAMIC flag is set, then it indicates that the
 * timer was dynamically allocated on the heap with caribou_timer_create(), and so will
 * be disposed of properly by caribou_timer_delete().
 * Otherwise, if the CARIBOU_TIMER_F_DYNAMIC is not set, then it is assumed that it is
 * a statically allocated, or stack allocated instance of a caribou_timer_t structure,
 * and so caribou_timer_delete() will make no attempt to de-allocate the memory associated with
 * the timer structure.
 */
#define	CARIBOU_TIMER_F_DYNAMIC		0x01		

/**
 * @brief Normally a caribou_timer_t will trigger a timeout callback upon the termination
 * of the timeout period, and once the callback is serviced, the period counter is then reloaded
 * and the timer restarted, such that the timer will repeat automatically at the specified period.
 * If the CARIBOU_TIMER_F_ONESHOT flag is set, then the timer callback is called exactly once at the
 * first expiration of the period counter. In either case, calling caribou_timer_reset() will
 * re-load the period counter and start the timer again.
 */
#define	CARIBOU_TIMER_F_ONESHOT		0x02		/// A one-shot timer, no-reload

typedef void* (caribou_timer_callback_fn)(void* thread, struct _caribou_timer_t* timer, void* arg);

/**
 * @brief The caribou_timer_t structure defines the data structure used by 
 * CARIBOU to maintain timers and sleep periods. The structure elements should not me
 * manipulated by the application program, and are subject to change in
 * future releases.
 */
typedef struct _caribou_timer_t
{
	struct _caribou_timer_t*	prev;		/// prev in chain
	struct _caribou_timer_t*	next;		/// next in chain
	caribou_timer_callback_fn*  timerfn;		/// timer callback function
	void*						fnarg;		/// timer callback argument
	uint32_t					ticks;		/// the remaining ticks
	uint32_t					reloadticks;/// the reload value
	uint8_t						flags;		/// the timer flags.
} caribou_timer_t;

/**
 * @brief The from_ms(msec) macro convert from milliseconds to native clock ticks 
 */
#define			from_ms(msec)	(msec/JIFFIES)
/**
 * @brief The to_ms(ticks) macro converts from native clock ticks to milliseconds
 */
#define			to_ms(ticks)	(ticks*JIFFIES)

/**
 * @brief Several CARIBOU functions take a timeout value as a parameter. In those cases,
 * The TIMEOUT_INFINITE constant may be used to indicate that the timeout period should
 * be infinite.
 */
#define			TIMEOUT_INFINITE	0

/**
 * @brief Several CARIBOU functions take a timeout value as a parameter. In those cases,
 * The TIMEOUT_INFINITE constant may be used to indicate that the timeout period should
 * be infinite.
 */
#define			TIMEOUT_IMMEDIATE	-1

#if !defined(caribou_tick_t)
	#define caribou_tick_t	int64_t
#endif

extern int					caribou_timer_period(void);
extern caribou_tick_t		caribou_timer_ticks(void);
extern bool					caribou_timer_ticks_timeout(caribou_tick_t start, caribou_tick_t timeout);
extern caribou_timer_t*		caribou_timer_create(caribou_timer_callback_fn* timerfn, void* arg, uint8_t flags);
extern caribou_timer_t*		caribou_timer_init(caribou_timer_t* timer, caribou_timer_callback_fn* timerfn, void* arg, uint8_t flags);
extern caribou_timer_t*		caribou_timer_reset( caribou_timer_t* timer );
extern caribou_timer_t*		caribou_timer_set( caribou_timer_t* timer, uint32_t ticks );
extern bool					caribou_timer_expired(caribou_timer_t* timer);
extern void					caribou_timer_delete( void* thread, caribou_timer_t* timer );
extern void					caribou_timer_delete_all( void* thread );
extern void					caribou_timer_usec_delay(uint32_t usecs);

#ifdef __cplusplus
}
#endif


#endif
