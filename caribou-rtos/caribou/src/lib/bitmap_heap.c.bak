/******************************************************************************
* Copyright Â© 2005-2012 by Pike Aerospace Research Corporation
* All Rights Reserved
*
*   This file is part of CARIBOU RTOS
*
*   CARIBOU RTOS is free software: you can redistribute it and/or modify
*   it under the terms of the Beerware License Version 43.
*
* ----------------------------------------------------------------------------
* "THE BEER-WARE LICENSE" (Revision 43):
* <mike@pikeaero.com> wrote this file. As long as you retain this notice you
* can do whatever you want with this stuff. If we meet some day, and you think
* this stuff is worth it, you can buy me a beer in return ~ Mike Sharkey
* ----------------------------------------------------------------------------
******************************************************************************/
#include <caribou/lib/bitmap_heap.h>

#define	ALL_BITS					0xFFFFFFFF
#define	HEAP_BLOCK_SIZE				16				/** The allocation block size in bytes */
#define HEAP_BLOCKS_PER_PAGE		32				/** Number of blocks per bitmap page */
#define HEAP_BYTES_PER_PAGE			(HEAP_BLOCKS_PER_PAGE * HEAP_BLOCK_SIZE)

#define isFree(block)				(!get_bitmap_bit(block,heap_free_bitmap))
#define	isUsed(block)				(get_bitmap_bit(block,heap_free_bitmap))
#define	set(block)					(set_bitmap_bit(block,heap_free_bitmap,true))
#define	reset(block)				(set_bitmap_bit(block,heap_free_bitmap,false))

#define	isLast(block)				(get_bitmap_bit(block,heap_last_bitmap))
#define	setLast(block)				(set_bitmap_bit(block,heap_last_bitmap,true))
#define	resetLast(block)			(set_bitmap_bit(block,heap_last_bitmap,false))

#define	valid(block)				(block >= 0 && block < heap_blocks)

#define	bit_offset(block)			(block % HEAP_BLOCKS_PER_PAGE)
#define	block_offset(block)			(block / HEAP_BLOCKS_PER_PAGE)

#define	to_blocks(size)				((size/HEAP_BLOCK_SIZE) + ((size%HEAP_BLOCK_SIZE)?1:0))

/**
 * notify memory allocated
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void notify_heap_alloc(int16_t blocks)
{
}

/**
 * notify memory free'd
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void notify_heap_dealloc(int16_t blocks)
{
}

/**
 * notify invalid free'd
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void notify_heap_invalid_dealloc(void* pointer)
{
	for(;;);
}

/**
 * notify invalid realloc'd
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void notify_heap_invalid_realloc(void* pointer, size_t size)
{
	for(;;);
}

/**
 * notify invalid alloc'd
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void notify_heap_alloc_failed(size_t size)
{
	for(;;);
}

/**
 * @brief	HEAP segment start.
 * @pre	  The symbol must be aligned to a 32 bits boundary.
 */
extern uint32_t __heap_start__;

/**
 * @brief	HEAP segment end.
 * @pre	  The symbol must be aligned to a 32 bits boundary.
 */
extern uint32_t __heap_end__;


/** static heap area. */
static uint32_t			heap_size;					/** The size of the heap memory area */
int16_t			heap_blocks;				/** The number of heap blocks */
static uint16_t			heap_bitmap_size;			/** The size of each heap bitmap */
static uint8_t*			heap_area;					/** heap memory area */
static uint32_t*		heap_free_bitmap;			/** bitmap of free blocks */
static uint32_t*		heap_last_bitmap;			/** bitmap marking last contiguouos block */

/**
* @brief Initialize memory.
*/
void bitmap_heap_init(void* heap_base, void* heap_end)
{
	/** Initialize the parameters based on the linkage map */
	uint32_t heapSegmentSize = (uint32_t)heap_end - (uint32_t)heap_base;
	uint32_t pageWords = (heapSegmentSize/HEAP_BYTES_PER_PAGE);
	heap_size = heapSegmentSize - ((pageWords*2)*sizeof(uint32_t));
	heap_blocks = heap_size / HEAP_BLOCK_SIZE;
	heap_bitmap_size = heap_blocks / HEAP_BLOCKS_PER_PAGE * sizeof(uint32_t);
	heap_free_bitmap = (uint32_t*)(heap_base);
	heap_last_bitmap = (uint32_t*)((uint32_t)heap_base+(pageWords*sizeof(uint32_t)));
	heap_area = (uint8_t*)((uint32_t)heap_base+((pageWords*2)*sizeof(uint32_t)));
	memset(heap_area,0,heap_size);
	memset(heap_free_bitmap,0,heap_bitmap_size);
	memset(heap_last_bitmap,0,heap_bitmap_size);
}

/**
** @brief the number of bytes per block
*/
int16_t bitmap_heap_block_size()
{
	return HEAP_BLOCK_SIZE;
}

/**
** @brief total up all the blocks used.
*/
int16_t bitmap_heap_blocks_allocated()
{
	int16_t n;
	int16_t total=0;
	int16_t block=0;
	while(block < heap_blocks )
	{
		uint32_t word = heap_free_bitmap[block_offset(block)];
		if((word & ALL_BITS) == ALL_BITS)
		{
			total += HEAP_BLOCKS_PER_PAGE;
		}
		else
		{
			for(n=0; n < HEAP_BLOCKS_PER_PAGE; n++)
			{
				total += ((word>>n)&1);
			}
		}
		block += HEAP_BLOCKS_PER_PAGE;
	}
	return total;
}

int32_t bitmap_heap_bytes_used()
{
	return heap_blocks_allocated()*HEAP_BLOCK_SIZE;
}

int32_t bitmap_heap_bytes_free()
{
	return (heap_blocks-heap_blocks_allocated())*HEAP_BLOCK_SIZE;
}

/**
* @brief lookup a bit in the bitmap and return it's state as a boolean.
*/
static bool get_bitmap_bit(int16_t block,uint32_t map[])
{
	if ( valid(block) )
	{
		return (map[block_offset(block)] & (1<<bit_offset(block))) ? true : false;
	}
	return false;
}


/**
* @brief determine if a sequence of blocks are free.
*/
static bool is_free_sequence(int16_t block, int16_t blocks)
{
	int16_t n;
	int16_t size = block+blocks;
	if ( size < heap_blocks )
	{
		for(n=block; n < size; n++)
		{
			if (isUsed(n))
			{
				return false;
			}
		}
		return true;
	}
	return false;
}

/**
* @brief Locate free space
* @param blocks The number of free blocks to try and find.
* @return The first block.
*/
static int16_t locate_free(int16_t blocks)
{
	int16_t n;
	int16_t block=0;
	uint32_t page=0;
	while(block < heap_blocks)
	{
		page = heap_free_bitmap[block_offset(block)];
		if ( ((page & ALL_BITS) != ALL_BITS) )	/* look at 32 blocks at a time... */
		{
			/* out of the next 32 bits, see if we can start the sequence */
			for(n=0; n < HEAP_BLOCKS_PER_PAGE; n++)
			{
				/* try each bit */
				if (is_free_sequence(block+n,blocks))
				{
					return block+n;
				}
			}
		}
		block += HEAP_BLOCKS_PER_PAGE;	/* we've looked at 32 blocks, skip past them */
	}
	return -1;
}

/**
* @brief Count the number of blocks used starting at a given block.
* @return number of blocks used.
*/
static int16_t blocks_used(int16_t block)
{
	int16_t used=0;
	if(valid(block))
	{
		while( block+used < heap_blocks && !isLast(block+(used++))) {}
	}
	return used;
}

/**
* @brief lookup a bit in the bitmap and set the bit state from a boolean.
*/
static void set_bitmap_bit(int16_t block,uint32_t map[],bool state)
{
	if ( valid(block) )
	{
		int16_t bitOffset = bit_offset(block);
		int16_t wordOffset = block_offset(block);
		if (state)
			map[wordOffset] |= (1<<bitOffset);
		else
			map[wordOffset] &= ~(1<<bitOffset);
	}
}

/**
* @brief Convert a pointer into a block offset.
* @return -1 on error or block offset
*/
static int16_t from_pointer(void* pointer)
{
	if (pointer!=NULL)
	{
		int16_t block = ((uint32_t)pointer - (uint32_t)heap_area)/HEAP_BLOCK_SIZE;
		if ( valid(block) )
		{
			return block;
		}
	}
	return -1;
}

/**
* @brief Convert a block offset into a pointer
*/
static void* to_pointer(int16_t block)
{
	void* pointer=NULL;
	if (valid(block))
	{
		pointer = &heap_area[block*HEAP_BLOCK_SIZE];
	}
	return pointer;
}

/**
 * @brief Allocate a contiguous range of blocks
 * @brief block The starting block from where to originate the allocation.
 * @brief blocks The number of blocks to allocate.
 * @return A pointer to the first byte of the allocated blocks, or NULL.
 */
static void* allocate(int16_t block, int16_t blocks)
{
	int16_t n;
	void* pointer=NULL;
	if ( valid(block) )
	{
		for(n=0; n < blocks; n++)
		{
			if (n == blocks-1)
				setLast(block+n);
			else
				resetLast(block+n);
			set(block+n);
		}
		pointer = to_pointer(block);
		notify_heap_alloc(blocks);
	}
	#if defined(CARIBOU_ZERO_HEAP_ALLOC)
		if ( pointer )
		{
			memset(pointer,0,blocks*HEAP_BLOCK_SIZE);
		}
	#endif
	return pointer;
}

/**
* @brief Deallocate a contiguous range of blocks
*/
static bool deallocate(int16_t block, int16_t blocks)
{
	uint16_t n;
	if ( valid(block) )
	{
		for(n=0; n < blocks; n++)
		{
			reset(block+n);
			resetLast(block+n);
		}
		notify_heap_dealloc(blocks);
		return true;
	}
	return false;
}

/**
* @brief Can the sequence of blocks starting at this block be extended by blocks amount?
* @param block The biginning block
* @param used How many blocks are currently used
* @param blocks the number of bocks to extend by
*/
static bool can_extend(int16_t block, int16_t used, int16_t blocks)
{
	int16_t n;
	bool rc=false;
	if ( valid(block) )
	{
		for(n=0; n < blocks; n++)
		{
			if (isUsed(block+used+n))
			{
				return rc;
			}
		}
		rc=true;
	}
	return rc;
}

/**
* @brief Extend a sequence of blocks starting at this block be extended by blocks amount.
* @param block The biginning block
* @param used How many blocks are currently used
* @param blocks the number of bocks to extend by
*/
static bool extend(int16_t block, int16_t used, int16_t blocks)
{
	int16_t n;
	bool rc=false;
	if ( can_extend(block,used,blocks) )
	{
		uint16_t total = used+blocks;
		for(n=0; n < total; n++)
		{
			if (n == total-1)
				setLast(block+n);
			else
				resetLast(block+n);
			set(block+n);
		}
		rc=true;
	}
	return rc;
}

/**
** malloc()  allocates  size bytes and returns a pointer to the allocated memory.  The memory is not cleared.  If size is 0, then
** malloc() returns either NULL, or a unique pointer value that can later be successfully passed to free().
*/
extern void* bitmap_heap_malloc(size_t size)
{
	void* pointer = NULL;
	if ( size > 0 )
	{
		int16_t blocks = to_blocks(size);
		int16_t block;
		int lvl = caribou_lib_lock();
		{
			block = locate_free(blocks);
			if ( block >= 0 )
			{
				pointer = allocate(block,blocks);
			}
			else
			{
				notify_heap_alloc_failed(size);
				pointer = NULL;
			}
		}
		caribou_lib_lock_restore(lvl);
	}
	return pointer;
}

/**
** realloc() changes the size of the memory block pointed to by ptr to size bytes.  The contents will be unchanged to the minimum
** of  the  old and new sizes; newly allocated memory will be uninitialized.  If ptr is NULL, then the call is equivalent to malâ
** loc(size), for all values of size; if size is equal to zero, and ptr is not NULL, then the call is  equivalent  to  free(ptr).
** Unless  ptr is NULL, it must have been returned by an earlier call to malloc() or realloc().  If the area pointed to
** was moved, a free(ptr) is done.
*/
extern void* bitmap_heap_realloc(void* pointer, size_t size)
{
	if (pointer != NULL && size > 0 )
	{
		int16_t blocks = to_blocks(size);
		int16_t block;
		int16_t used;
		int lvl = caribou_lib_lock();
		block = from_pointer(pointer);
		if ( block >= 0 )
		{
			used = blocks_used(block);
			if (blocks > used)
			{
				if (!extend(block,used,blocks-used))		/* attempt to extend existing block */
				{
					int16_t target;
					deallocate(block,used);					/* make currently allocated blocks available to be re-allocated.. */
					target = locate_free(blocks);			/* ...then attempts to locate a sequence of free blocks... */
					if (target >= 0 )
					{
						void* pTarget = allocate(target,blocks);	/* allocate the new blocks... */
						memmove(pTarget,pointer,used*HEAP_BLOCK_SIZE);	/* ...and move the data to the new area. */
						pointer = pTarget;
					}
					else
					{
						/* The re-allocation failed. The current blocks are already marked free, so just NULL the pointer */
						notify_heap_invalid_realloc(pointer,size);
						pointer = NULL;
					}
				}
			}
			else if (blocks < used)
			{
				/* shrink the allocation */
				deallocate(block,used);
				allocate(block,blocks);
			}
		}
		else
		{
			notify_heap_invalid_realloc(pointer,size);
			pointer = NULL;
		}
		caribou_lib_lock_restore(lvl);
	}
	else if (pointer != NULL && size == 0)
	{
		bitmap_heap_free(pointer);
		pointer=NULL;
	}
	else if (pointer == NULL )
	{
		pointer = bitmap_heap_malloc(size);
	}
	return pointer;
}

/**
 ** The  calloc()  function allocates memory for an array of nmemb elements of size bytes each and returns a pointer to the
 ** allocated memory.  The memory is set to zero.  If nmemb or size is 0, then calloc() returns either NULL,  or  a  unique
 ** pointer value that can later be successfully passed to free().
 */
extern void* bitmap_heap_calloc(size_t nmemb, size_t size)
{
	void* rc = bitmap_heap_malloc(nmemb*size);
	return rc;
}

/**
** free() frees the memory space pointed to by ptr, which must have been returned by a previous call  to  malloc() or
** realloc().   Otherwise,  or if free(ptr) has already been called before, undefined behavior occurs.  If ptr is NULL, no operaâ
** tion is performed.
*/
extern void bitmap_heap_free(void* pointer)
{
	int16_t block;
	int16_t used;
	int lvl = caribou_lib_lock();
	block = from_pointer(pointer);
	if ( block != 0 )
	{
		used = blocks_used(block);
		deallocate(block,used);
	}
	else
	{
		notify_heap_invalid_dealloc(pointer);
	}
	caribou_lib_lock_restore(lvl);
}

