/******************************************************************************
* Copyright Â© 2005-2012 by Pike Aerospace Research Corporation
* All Rights Reserved
*
*   This file is part of CARIBOU RTOS.
*
*   CARIBOU RTOS is free software: you can redistribute it and/or modify
*   it under the terms of the Beerware License Version 43.
*
* ----------------------------------------------------------------------------
* "THE BEER-WARE LICENSE" (Revision 43):
* <mike@pikeaero.com> wrote this file. As long as you retain this notice you
* can do whatever you want with this stuff. If we meet some day, and you think
* this stuff is worth it, you can buy me a beer in return ~ Mike Sharkey
* ----------------------------------------------------------------------------
******************************************************************************/
			.code		32
			.align		0
			.global 	irq_handler
			.global 	irq_handler
			.global 	_fiq_systick
			.global		caribou_systick
			.global		caribou_interrupt_service
			.global		irq_vector_lpc2468
			.global		chip_systick_enter
			.global		chip_systick_exit

			.section	.init
irq_handler:
			// check if I bit is set in SPSR to detect interrupt occuring during interrupt disable
			msr			cpsr_c, #0xd2			// irq mode (18), irq & fiq interrupts disabled
			stmfd		sp!, {r0}				// scratch
			mrs			r0, spsr				// 
			tst			r0, #0x80
			ldmfd		sp!, {r0}
			subnes		pc, lr, #4				// return without VIC ack.

			// okay, now really enter the interrupt service...
			stmfd		sp!, {r0-r12, lr}
			
			// Get the vector from VIC...
			ldr			r1, VICVECT
			ldr			r0, [r1]
			mrs			r2, spsr
			stmfd		sp!, {r2}
			/*
			 * We're disabling FIQ since we're using FIQ as the systick interrupt to drive the thread scheduler
			 * there was some problems with switching context while in an interrupt hasndler, so therefore, we
			 * are disallowing FIQ (potential context switch) to occure during the IRQ.
			 * We never want to initiate a context switch during an interrupt service routine.
			*/
			/*
			 * The following line will enable nested IRQs.
			 * However, caution that FIQ is re-enabled after a single IRQ....
			 * We don't want a context switch to occur inside an interrupt handler.
			 * Should we use a count here and only re-enable FIQ when the last IRQ is done?
			 */
			//msr			cpsr_c, #0x52 // irq mode, irq interrupts enabled, fiq disabled
			stmfd		sp!, {lr}
			bl			caribou_interrupt_service
			ldmfd		sp!, {lr}
			msr			cpsr_c, #0xd2 // irq mode, irq & fiq interrupts disabled
			ldmfd		sp!, {r2}
			msr			spsr_cxsf, r2
			// Clear the VIC...
			mov			r3, #0
			ldr			r2, VICVECT
			str			r3, [r2]
			ldmfd		sp!, {r0-r12, lr}
			subs		pc, lr, #4

VICVECT:
		.word		0xFFFFFF00

/******************************************************************************
* entry to systick generated by VIC + FIQ
******************************************************************************/
			.code		32
			.align		0

			.set		MODE_USR,			0x10
			.set		MODE_FIQ,			0x11
			.set		MODE_IRQ,			0x12
			.set		MODE_SVC,			0x13
			.set		MODE_ABT,			0x17
			.set		MODE_UND,			0x1B
			.set		MODE_SYS,			0x1F
			.equ		I_BIT,				0x80
			.equ		F_BIT,				0x40

_fiq_systick:
	/*********************************************************************
	*  FIQ Stack     Copy        SYS Stack                               *
	*  ---------     ----        ---------                               *
	*                                       [SP]                         *
	* 12  pc                                                             *
	* 8   r1                                                             *
	* 4   r0                                                             *
	* 0   spsr	[SP]                                                     *
	*                                                                    *
	**********************************************************************/
			sub			lr,lr,#4
			stmfd		sp!,{r0-r1,lr}
			mrs			r0,spsr
			stmfd		sp!,{r0}
	/*********************************************************************
	*  FIQ Stack     Copy        SYS Stack                               *
	*  ---------     ----        ---------                               *
	*                                                                    *
	* 12  pc          >          pc                  60   (12)           *
	* 8   r1          >          spsr                56    (8)           *
	* 4   r0	      >          lr_sys              52    (4)           *
	* 0   spsr	[SP]  >          r12                 48    (0)           *
	*                            |                                       *
	*                            r2                  8                   *
	*                            r1                  4                   *
	*                            r0        [SP]      0                   *
	*                                                                    *
	**********************************************************************/
			mov			r0,sp
			msr			CPSR_c,#MODE_SYS|I_BIT|F_BIT	/* SYS mode, ints diabled */
			ldr			r1,[r0,#12]
			stmfd		sp!,{r1}
			ldr			r1,[r0,#0]
			stmfd		sp!,{r1}
			stmfd		sp!,{r2-r12,lr}
			ldr			r1,[r0,#8]
			stmfd		sp!,{r1}
			ldr			r0,[r0,#4]
			stmfd		sp!,{r0}

			// call device driver systick entry processing...
			ldr			r0,=chip_systick_enter
			mov			lr, pc
			bx			r0

			// test if we came out of system mode...
			ldr			r0,[sp,#56]
			and			r0,r0,#0x1F
			cmp			r0,#0x1F				/* was in system mode? */
			bne			_systick_abort			/* no? no context switch for you... */
			msr			CPSR_c,#MODE_FIQ|I_BIT|F_BIT	/* FIQ ints disabled */

			// call caribou_systick for potential context switch...
			ldr			r0,=caribou_systick
			mov			lr, pc					/* calculate return address */
			add			lr,#8
			stmfd		sp!,{lr}				/* stack the return address */
			bx			r0						/* do the systick...systick_exit() will pop lr */

	/*********************************************************************
	*  FIQ Stack     Copy        SYS Stack                               *
	*  ---------     ----        ---------                               *
	*           [SP]                       [SP]                          *
	* 12  pc          <          pc   (lr_sys)       60   (12)           *
	* 8   r1          <          spsr (lr_sys)       56    (8)           *
	* 4   r0	      <          lr_sys --^          52    (4)           *
	* 0   spsr	      <          r12                 48    (0)           *
	*                            |                                       *
	*                            r2                  8                   *
	*                            r1                  4                   *
	*                            r0                  0                   *
	*                                                                    *
	**********************************************************************/
_systick_abort:
			msr			CPSR_c,#MODE_FIQ|I_BIT|F_BIT /* FIQ ints diabled */

			// call device driver systick exit processing...
			ldr			r0,=chip_systick_exit
			mov			lr, pc
			bx			r0

			msr			CPSR_c,#MODE_SYS|I_BIT|F_BIT
			mov			r0,sp
			msr			CPSR_c,#MODE_FIQ|I_BIT|F_BIT
			ldr			r1,[r0,#60]
			str			r1,[sp,#12]
			ldr			r1,[r0,#4]
			str			r1,[sp,#8]
			ldr			r1,[r0,#0]
			str			r1,[sp,#4]
			ldr			r1,[r0,#56]
			str			r1,[sp,#0]
			msr			CPSR_c,#MODE_SYS|I_BIT|F_BIT
			ldmfd		sp!,{r0-r11}
			ldr			r12,[sp,#4]
			str			r12,[sp,#8]
			str			r12,[sp,#12]
			ldmfd		sp!,{r12,lr}
			ldmfd		sp!,{lr}
			ldmfd		sp!,{lr}
			msr			CPSR_c,#MODE_FIQ|I_BIT|F_BIT

	/*********************************************************************
	*  FIQ Stack     Copy        SYS Stack                               *
	*  ---------     ----        ---------                               *
	*           [SP]                        [SP]                         *
	* 12  pc                                                             *
	* 8   r1                                                             *
	* 4   r0                                                             *
	* 0   spsr	                                                         *
	*                                                                    *
	**********************************************************************/
			ldmfd		sp!,{r0}
			msr			spsr,r0
			ldmfd		sp!,{r0-r1,pc}^

			.end
