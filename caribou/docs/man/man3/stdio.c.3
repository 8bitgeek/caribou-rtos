.TH "src/lib/stdio.c" 3 "Thu Dec 29 2016" "Version 0.9" "CARIBOU RTOS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/lib/stdio.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <caribou\&.h>\fP
.br
\fC#include <caribou/kernel/thread\&.h>\fP
.br
\fC#include <caribou/lib/stdio\&.h>\fP
.br
\fC#include <caribou/lib/heap\&.h>\fP
.br
\fC#include <caribou/lib/string\&.h>\fP
.br
\fC#include <caribou/lib/stdarg\&.h>\fP
.br
\fC#include <caribou/dev/uart\&.h>\fP
.br
\fC#include <chip/uart\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBPRINT_BUF_LEN\fP   12"
.br
.ti -1c
.RI "#define \fBPAD_RIGHT\fP   1"
.br
.ti -1c
.RI "#define \fBPAD_ZERO\fP   2"
.br
.ti -1c
.RI "#define \fBISSPACE\fP   ' \\t\\n\\r\\f\\v'"
.br
.ti -1c
.RI "#define \fBMAXLN\fP   255"
.br
.ti -1c
.RI "#define \fBin_range\fP(c, lo, up)   ((uint8_t)c >= lo && (uint8_t)c <= up)"
.br
.ti -1c
.RI "#define \fBisprint\fP(c)   \fBin_range\fP(c, 0x20, 0x7f)"
.br
.ti -1c
.RI "#define \fBisdigit\fP(c)   \fBin_range\fP(c, '0', '9')"
.br
.ti -1c
.RI "#define \fBisxdigit\fP(c)   (\fBisdigit\fP(c) || \fBin_range\fP(c, 'a', 'f') || \fBin_range\fP(c, 'A', 'F'))"
.br
.ti -1c
.RI "#define \fBislower\fP(c)   \fBin_range\fP(c, 'a', 'z')"
.br
.ti -1c
.RI "#define \fBisspace\fP(c)   (c == ' ' || c == '\\f' || c == '\\n' || c == '\\r' || c == '\\t' || c == '\\v')"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static char * \fB_getbase\fP (char *p, int *basep)"
.br
.ti -1c
.RI "static int \fB_atob\fP (unsigned long long *vp, char *p, int base)"
.br
.ti -1c
.RI "int \fBatob\fP (uint32_t *vp, char *p, int base)"
.br
.ti -1c
.RI "int \fBllatob\fP (unsigned long long *vp, char *p, int base)"
.br
.ti -1c
.RI "char * \fBbtoa\fP (char *dst, uint32_t value, int base)"
.br
.ti -1c
.RI "char * \fBllbtoa\fP (char *dst, unsigned long long value, int base)"
.br
.ti -1c
.RI "int \fBgethex\fP (int32_t *vp, char *p, int n)"
.br
.ti -1c
.RI "int \fB_fd\fP (\fBstdio_t\fP *fp)"
.br
.ti -1c
.RI "\fBFILE\fP * \fBfopen\fP (int ndev, const char *mode)"
.br
.ti -1c
.RI "int \fBfclose\fP (\fBFILE\fP *fp)"
.br
.ti -1c
.RI "int \fBfflush\fP (\fBFILE\fP *fp)"
.br
.RI "\fIFlush the stream\&. \fP"
.ti -1c
.RI "int \fBfputc\fP (int c, \fBFILE\fP *fp)"
.br
.RI "\fIWrite a character to the FILE* stream\&. \fP"
.ti -1c
.RI "int \fBputc\fP (int c, \fBFILE\fP *fp)"
.br
.RI "\fIWrite a character to the FILE* stream\&. \fP"
.ti -1c
.RI "\fB__attribute__\fP ((weak))"
.br
.ti -1c
.RI "int \fBfputs\fP (const char *s, \fBFILE\fP *fp)"
.br
.ti -1c
.RI "int \fBfgetc\fP (\fBFILE\fP *fp)"
.br
.RI "\fInon-blocking read character from input stream\&. \fP"
.ti -1c
.RI "char * \fBfgets\fP (char *s, int size, \fBFILE\fP *fp)"
.br
.RI "\fI\fBfgets()\fP reads in at most one less than size characters from stream and stores them into the buffer pointed to by s\&. Reading stops after an EOF or a newline\&. If a newline is read, it is stored into the buffer\&. A terminating null byte ('\\0') is stored after the last character in the buffer\&. \fP"
.ti -1c
.RI "static void \fBprintchar\fP (\fBFILE\fP *fp, char **str, int c)"
.br
.ti -1c
.RI "static int \fBprints\fP (\fBFILE\fP *fp, char **out, const char *string, int width, int pad)"
.br
.ti -1c
.RI "static int \fBprinti\fP (\fBFILE\fP *fp, char **out, long i, int b, int sg, int width, int pad, int letbase)"
.br
.ti -1c
.RI "static int \fBprint\fP (\fBFILE\fP *fp, char **out, const char *format, \fBva_list\fP args)"
.br
.ti -1c
.RI "int \fBscanf\fP (const char *fmt,\&.\&.\&.)"
.br
.ti -1c
.RI "int \fBfscanf\fP (\fBFILE\fP *fp, const char *fmt,\&.\&.\&.)"
.br
.ti -1c
.RI "int \fBsscanf\fP (const char *buf, const char *fmt,\&.\&.\&.)"
.br
.ti -1c
.RI "int \fBvfscanf\fP (\fBFILE\fP *fp, const char *fmt, \fBva_list\fP ap)"
.br
.ti -1c
.RI "int \fBvsscanf\fP (const char *buf, const char *s, \fBva_list\fP ap)"
.br
.ti -1c
.RI "int \fBsprintf\fP (char *str, const char *format,\&.\&.\&.)"
.br
.RI "\fIFormatted print to FILE* stream\&. \fP"
.ti -1c
.RI "int \fBsnprintf\fP (char *str, size_t size, const char *format,\&.\&.\&.)"
.br
.RI "\fIFormatted print to FILE* stream\&. \fP"
.ti -1c
.RI "int \fBfprintf\fP (\fBFILE\fP *fp, const char *format,\&.\&.\&.)"
.br
.RI "\fIFormatted print to FILE* stream\&. \fP"
.ti -1c
.RI "int \fBprintf\fP (const char *format,\&.\&.\&.)"
.br
.RI "\fIFormatted print to FILE* stdout\&. \fP"
.ti -1c
.RI "int \fBfwrite\fP (char *p, size_t len, size_t nmemb, \fBFILE\fP *fp)"
.br
.RI "\fIFormatted print to debug\&. \fP"
.ti -1c
.RI "int \fBfread\fP (char *p, size_t len, size_t nmemb, \fBFILE\fP *fp)"
.br
.ti -1c
.RI "int \fBfioctl\fP (\fBFILE\fP *fp)"
.br
.ti -1c
.RI "int \fBgetchar\fP ()"
.br
.ti -1c
.RI "int \fBputchar\fP (int ch)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBstdio_t\fP * \fB_stdin\fP =0"
.br
.ti -1c
.RI "\fBstdio_t\fP * \fB_stdout\fP =0"
.br
.ti -1c
.RI "\fBstdio_t\fP * \fB_stderr\fP =0"
.br
.in -1c
.SH "Detailed Description"
.PP 

.PP
.PP
\fBAuthor:\fP
.RS 4
Mike Sharkey mike@pikeaero.com\&. 
.RE
.PP
\fBCopyright:\fP
.RS 4
© 2005-2013 by Pike Aerospace Research Corporation 
.PP
© 2014-2015 by Mike Sharkey
.RE
.PP
This file is part of CARIBOU RTOS CARIBOU RTOS is free software: you can redistribute it and/or modify it under the terms of the Beerware License Version 43\&. 'THE BEER-WARE LICENSE' (Revision 43): Mike Sharkey mike@pikeaero.com wrote this file\&. As long as you retain this notice you can do whatever you want with this stuff\&. If we meet some day, and you think this stuff is worth it, you can buy me a beer in return ~ Mike Sharkey 
.PP
Definition in file \fBstdio\&.c\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define in_range(c, lo, up)   ((uint8_t)c >= lo && (uint8_t)c <= up)"

.PP
Definition at line 35 of file stdio\&.c\&.
.SS "#define isdigit(c)   \fBin_range\fP(c, '0', '9')"

.PP
Definition at line 37 of file stdio\&.c\&.
.SS "#define islower(c)   \fBin_range\fP(c, 'a', 'z')"

.PP
Definition at line 39 of file stdio\&.c\&.
.SS "#define isprint(c)   \fBin_range\fP(c, 0x20, 0x7f)"

.PP
Definition at line 36 of file stdio\&.c\&.
.SS "#define ISSPACE   ' \\t\\n\\r\\f\\v'"

.PP
Definition at line 32 of file stdio\&.c\&.
.SS "#define isspace(c)   (c == ' ' || c == '\\f' || c == '\\n' || c == '\\r' || c == '\\t' || c == '\\v')"

.PP
Definition at line 40 of file stdio\&.c\&.
.SS "#define isxdigit(c)   (\fBisdigit\fP(c) || \fBin_range\fP(c, 'a', 'f') || \fBin_range\fP(c, 'A', 'F'))"

.PP
Definition at line 38 of file stdio\&.c\&.
.SS "#define MAXLN   255"

.PP
Definition at line 33 of file stdio\&.c\&.
.SS "#define PAD_RIGHT   1"

.PP
Definition at line 30 of file stdio\&.c\&.
.SS "#define PAD_ZERO   2"

.PP
Definition at line 31 of file stdio\&.c\&.
.SS "#define PRINT_BUF_LEN   12"

.PP
Definition at line 29 of file stdio\&.c\&.
.SH "Function Documentation"
.PP 
.SS "__attribute__ ((weak))"

.PP
Definition at line 340 of file stdio\&.c\&.
.SS "static int _atob (unsigned long long *vp, char *p, intbase)\fC [static]\fP"

.PP
Definition at line 69 of file stdio\&.c\&.
.SS "int _fd (\fBstdio_t\fP *fp)"

.PP
Definition at line 269 of file stdio\&.c\&.
.SS "static char* _getbase (char *p, int *basep)\fC [static]\fP"

.PP
Definition at line 42 of file stdio\&.c\&.
.SS "int atob (uint32_t *vp, char *p, intbase)"

.PP
Definition at line 123 of file stdio\&.c\&.
.SS "char* btoa (char *dst, uint32_tvalue, intbase)"

.PP
Definition at line 153 of file stdio\&.c\&.
.SS "int fclose (\fBFILE\fP *fp)"

.PP
Definition at line 295 of file stdio\&.c\&.
.SS "int fflush (\fBFILE\fP *fp)"

.PP
Flush the stream\&. 
.PP
Definition at line 308 of file stdio\&.c\&.
.SS "int fgetc (\fBFILE\fP *fp)"

.PP
non-blocking read character from input stream\&. 
.PP
\fBReturns:\fP
.RS 4
The character read, or -1 if character not ready or EOF was encountered\&. 
.RE
.PP

.PP
Definition at line 361 of file stdio\&.c\&.
.SS "char* fgets (char *s, intsize, \fBFILE\fP *fp)"

.PP
\fBfgets()\fP reads in at most one less than size characters from stream and stores them into the buffer pointed to by s\&. Reading stops after an EOF or a newline\&. If a newline is read, it is stored into the buffer\&. A terminating null byte ('\\0') is stored after the last character in the buffer\&. 
.PP
\fBReturns:\fP
.RS 4
gets() and \fBfgets()\fP return s on success, and NULL on error or when end of file occurs while no characters have been read\&. 
.RE
.PP

.PP
Definition at line 381 of file stdio\&.c\&.
.SS "int fioctl (\fBFILE\fP *fp)"

.PP
Definition at line 838 of file stdio\&.c\&.
.SS "\fBFILE\fP* fopen (intndev, const char *mode)"

.PP
Definition at line 284 of file stdio\&.c\&.
.SS "int fprintf (\fBFILE\fP *fp, const char *format, \&.\&.\&.)"

.PP
Formatted print to FILE* stream\&. 
.PP
Definition at line 785 of file stdio\&.c\&.
.SS "int fputc (intc, \fBFILE\fP *fp)"

.PP
Write a character to the FILE* stream\&. 
.PP
\fBReturns:\fP
.RS 4
return character written or -1 + errno if character was not written\&. 
.RE
.PP

.PP
Definition at line 318 of file stdio\&.c\&.
.SS "int fputs (const char *s, \fBFILE\fP *fp)"
Write a characters to the FILE* stream\&. return number of characters written or -1 + errno if characters where not written\&. 
.PP
Definition at line 347 of file stdio\&.c\&.
.SS "int fread (char *p, size_tlen, size_tnmemb, \fBFILE\fP *fp)"

.PP
Definition at line 833 of file stdio\&.c\&.
.SS "int fscanf (\fBFILE\fP *fp, const char *fmt, \&.\&.\&.)"

.PP
Definition at line 617 of file stdio\&.c\&.
.SS "int fwrite (char *p, size_tlen, size_tnmemb, \fBFILE\fP *fp)"

.PP
Formatted print to debug\&. 
.PP
Definition at line 828 of file stdio\&.c\&.
.SS "int getchar ()"

.PP
Definition at line 843 of file stdio\&.c\&.
.SS "int gethex (int32_t *vp, char *p, intn)"

.PP
Definition at line 244 of file stdio\&.c\&.
.SS "int llatob (unsigned long long *vp, char *p, intbase)"

.PP
Definition at line 141 of file stdio\&.c\&.
.SS "char* llbtoa (char *dst, unsigned long longvalue, intbase)"

.PP
Definition at line 198 of file stdio\&.c\&.
.SS "static int print (\fBFILE\fP *fp, char **out, const char *format, \fBva_list\fPargs)\fC [static]\fP"

.PP
Definition at line 500 of file stdio\&.c\&.
.SS "static void printchar (\fBFILE\fP *fp, char **str, intc)\fC [static]\fP"

.PP
Definition at line 403 of file stdio\&.c\&.
.SS "int printf (const char *format, \&.\&.\&.)"

.PP
Formatted print to FILE* stdout\&. 
.PP
Definition at line 799 of file stdio\&.c\&.
.SS "static int printi (\fBFILE\fP *fp, char **out, longi, intb, intsg, intwidth, intpad, intletbase)\fC [static]\fP"

.PP
Definition at line 453 of file stdio\&.c\&.
.SS "static int prints (\fBFILE\fP *fp, char **out, const char *string, intwidth, intpad)\fC [static]\fP"

.PP
Definition at line 418 of file stdio\&.c\&.
.SS "int putc (intc, \fBFILE\fP *fp)"

.PP
Write a character to the FILE* stream\&. 
.PP
\fBReturns:\fP
.RS 4
return character written or -1 + errno if character was not written\&. 
.RE
.PP

.PP
Definition at line 331 of file stdio\&.c\&.
.SS "int putchar (intch)"

.PP
Definition at line 848 of file stdio\&.c\&.
.SS "int scanf (const char *fmt, \&.\&.\&.)"

.PP
Definition at line 603 of file stdio\&.c\&.
.SS "int snprintf (char *str, size_tsize, const char *format, \&.\&.\&.)"

.PP
Formatted print to FILE* stream\&. 
.PP
Definition at line 772 of file stdio\&.c\&.
.SS "int sprintf (char *str, const char *format, \&.\&.\&.)"

.PP
Formatted print to FILE* stream\&. 
.PP
Definition at line 759 of file stdio\&.c\&.
.SS "int sscanf (const char *buf, const char *fmt, \&.\&.\&.)"

.PP
Definition at line 631 of file stdio\&.c\&.
.SS "int vfscanf (\fBFILE\fP *fp, const char *fmt, \fBva_list\fPap)"

.PP
Definition at line 645 of file stdio\&.c\&.
.SS "int vsscanf (const char *buf, const char *s, \fBva_list\fPap)"

.PP
Definition at line 659 of file stdio\&.c\&.
.SH "Variable Documentation"
.PP 
.SS "\fBstdio_t\fP* _stderr =0"

.PP
Definition at line 26 of file stdio\&.c\&.
.SS "\fBstdio_t\fP* _stdin =0"

.PP
Definition at line 24 of file stdio\&.c\&.
.SS "\fBstdio_t\fP* _stdout =0"

.PP
Definition at line 25 of file stdio\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for CARIBOU RTOS from the source code\&.
