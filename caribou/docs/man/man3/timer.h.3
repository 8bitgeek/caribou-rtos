.TH "include/caribou/kernel/timer.h" 3 "Thu Dec 29 2016" "Version 0.9" "CARIBOU RTOS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/caribou/kernel/timer.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <caribou/kernel/types\&.h>\fP
.br
\fC#include <chip/chip\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fB_caribou_timer_t\fP"
.br
.RI "\fIThe caribou_timer_t structure defines the data structure used by CARIBOU to maintain timers and sleep periods\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBCARIBOU_TIMER_F_DYNAMIC\fP   0x01"
.br
.RI "\fIIf the CARIBOU_TIMER_F_DYNAMIC flag is set, then it indicates that the timer was dynamically allocated on the heap with \fBcaribou_timer_create()\fP, and so will be disposed of properly by \fBcaribou_timer_delete()\fP\&. Otherwise, if the CARIBOU_TIMER_F_DYNAMIC is not set, then it is assumed that it is a statically allocated, or stack allocated instance of a caribou_timer_t structure, and so \fBcaribou_timer_delete()\fP will make no attempt to de-allocate the memory associated with the timer structure\&. \fP"
.ti -1c
.RI "#define \fBCARIBOU_TIMER_F_ONESHOT\fP   0x02"
.br
.RI "\fINormally a caribou_timer_t will trigger a timeout callback upon the termination of the timeout period, and once the callback is serviced, the period counter is then reloaded and the timer restarted, such that the timer will repeat automatically at the specified period\&. If the CARIBOU_TIMER_F_ONESHOT flag is set, then the timer callback is called exactly once at the first expiration of the period counter\&. In either case, calling \fBcaribou_timer_reset()\fP will re-load the period counter and start the timer again\&. \fP"
.ti -1c
.RI "#define \fBfrom_ms\fP(msec)   (msec/JIFFIES)"
.br
.RI "\fIThe \fBfrom_ms(msec)\fP macro convert from milliseconds to native clock ticks\&. \fP"
.ti -1c
.RI "#define \fBto_ms\fP(ticks)   (ticks*JIFFIES)"
.br
.RI "\fIThe \fBto_ms(ticks)\fP macro converts from native clock ticks to milliseconds\&. \fP"
.ti -1c
.RI "#define \fBTIMEOUT_INFINITE\fP   0"
.br
.RI "\fISeveral CARIBOU functions take a timeout value as a parameter\&. In those cases, The TIMEOUT_INFINITE constant may be used to indicate that the timeout period should be infinite\&. \fP"
.ti -1c
.RI "#define \fBTIMEOUT_IMMEDIATE\fP   -1"
.br
.RI "\fISeveral CARIBOU functions take a timeout value as a parameter\&. In those cases, The TIMEOUT_IMMEDIATE constant may be used to indicate that the timeout period should be immediate, such that the function call always returns immediately\&. \fP"
.ti -1c
.RI "#define \fBcaribou_tick_t\fP   int64_t"
.br
.RI "\fIThe caribou_tick_t macro should be used at the data type whenever referring to the native tick (JIFFY) counter data type\&. In some cases it may be desirable to make it a 64 bit value, and in others 32 bit for instance\&. \fP"
.ti -1c
.RI "#define \fBcaribou_timer_period\fP()   (JIFFIES)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void *( \fBcaribou_timer_callback_fn\fP )(void *thread, struct \fB_caribou_timer_t\fP *timer, void *arg)"
.br
.ti -1c
.RI "typedef struct \fB_caribou_timer_t\fP \fBcaribou_timer_t\fP"
.br
.RI "\fIThe caribou_timer_t structure defines the data structure used by CARIBOU to maintain timers and sleep periods\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBbool\fP \fBcaribou_timer_ticks_timeout\fP (\fBcaribou_tick_t\fP start, \fBcaribou_tick_t\fP timeout)"
.br
.RI "\fIDetermine of the timeout period has expired in relationn to the start time\&. \fP"
.ti -1c
.RI "\fBcaribou_timer_t\fP * \fBcaribou_timer_create\fP (\fBcaribou_timer_callback_fn\fP *timerfn, void *arg, uint8_t flags)"
.br
.RI "\fIInstantiate a new timer on the heap memory, and associate it with the current thread\&.  timerfn The timer callback function\&. \fP"
.ti -1c
.RI "\fBcaribou_tick_t\fP \fBcaribou_timer_ticks\fP ()"
.br
.ti -1c
.RI "\fBcaribou_timer_t\fP * \fBcaribou_timer_init\fP (\fBcaribou_timer_t\fP *timer, \fBcaribou_timer_callback_fn\fP *timerfn, void *arg, uint8_t flags)"
.br
.ti -1c
.RI "\fBcaribou_timer_t\fP * \fBcaribou_timer_reset\fP (\fBcaribou_timer_t\fP *timer)"
.br
.RI "\fIReset the period of the specified timer\&. \fP"
.ti -1c
.RI "\fBcaribou_timer_t\fP * \fBcaribou_timer_set\fP (\fBcaribou_timer_t\fP *timer, uint32_t ticks)"
.br
.RI "\fISet the period of the specified timer\&. \fP"
.ti -1c
.RI "\fBbool\fP \fBcaribou_timer_expired\fP (\fBcaribou_timer_t\fP *timer)"
.br
.RI "\fIThe \fBcaribou_timer_expired()\fP function is used to determine if a timer has expired\&. \fP"
.ti -1c
.RI "void \fBcaribou_timer_delete\fP (void *thread, \fBcaribou_timer_t\fP *timer)"
.br
.RI "\fIDispose of a timer instance associated with a thread\&. \fP"
.ti -1c
.RI "void \fBcaribou_timer_delete_all\fP (void *thread)"
.br
.RI "\fIDispose of all timer instances associated with a thread\&. \fP"
.ti -1c
.RI "void \fBcaribou_timer_usec_delay\fP (uint32_t usecs)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.PP
.PP
\fBAuthor:\fP
.RS 4
Mike Sharkey mike@pikeaero.com\&. 
.RE
.PP
\fBCopyright:\fP
.RS 4
© 2005-2013 by Pike Aerospace Research Corporation 
.PP
© 2014-2015 by Mike Sharkey
.RE
.PP
This file is part of CARIBOU RTOS CARIBOU RTOS is free software: you can redistribute it and/or modify it under the terms of the Beerware License Version 43\&. 'THE BEER-WARE LICENSE' (Revision 43): Mike Sharkey mike@pikeaero.com wrote this file\&. As long as you retain this notice you can do whatever you want with this stuff\&. If we meet some day, and you think this stuff is worth it, you can buy me a beer in return ~ Mike Sharkey 
.PP
Definition in file \fBtimer\&.h\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define caribou_tick_t   int64_t"

.PP
The caribou_tick_t macro should be used at the data type whenever referring to the native tick (JIFFY) counter data type\&. In some cases it may be desirable to make it a 64 bit value, and in others 32 bit for instance\&. 
.PP
Definition at line 103 of file timer\&.h\&.
.SS "#define CARIBOU_TIMER_F_DYNAMIC   0x01"

.PP
If the CARIBOU_TIMER_F_DYNAMIC flag is set, then it indicates that the timer was dynamically allocated on the heap with \fBcaribou_timer_create()\fP, and so will be disposed of properly by \fBcaribou_timer_delete()\fP\&. Otherwise, if the CARIBOU_TIMER_F_DYNAMIC is not set, then it is assumed that it is a statically allocated, or stack allocated instance of a caribou_timer_t structure, and so \fBcaribou_timer_delete()\fP will make no attempt to de-allocate the memory associated with the timer structure\&. 
.PP
Definition at line 35 of file timer\&.h\&.
.SS "#define CARIBOU_TIMER_F_ONESHOT   0x02"

.PP
Normally a caribou_timer_t will trigger a timeout callback upon the termination of the timeout period, and once the callback is serviced, the period counter is then reloaded and the timer restarted, such that the timer will repeat automatically at the specified period\&. If the CARIBOU_TIMER_F_ONESHOT flag is set, then the timer callback is called exactly once at the first expiration of the period counter\&. In either case, calling \fBcaribou_timer_reset()\fP will re-load the period counter and start the timer again\&. 
.PP
Definition at line 45 of file timer\&.h\&.
.SS "#define caribou_timer_period()   (JIFFIES)"

.PP
Definition at line 106 of file timer\&.h\&.
.SS "#define from_ms(msec)   (msec/JIFFIES)"

.PP
The \fBfrom_ms(msec)\fP macro convert from milliseconds to native clock ticks\&. 
.PP
Definition at line 77 of file timer\&.h\&.
.SS "#define TIMEOUT_IMMEDIATE   -1"

.PP
Several CARIBOU functions take a timeout value as a parameter\&. In those cases, The TIMEOUT_IMMEDIATE constant may be used to indicate that the timeout period should be immediate, such that the function call always returns immediately\&. 
.PP
Definition at line 95 of file timer\&.h\&.
.SS "#define TIMEOUT_INFINITE   0"

.PP
Several CARIBOU functions take a timeout value as a parameter\&. In those cases, The TIMEOUT_INFINITE constant may be used to indicate that the timeout period should be infinite\&. 
.PP
Definition at line 88 of file timer\&.h\&.
.SS "#define to_ms(ticks)   (ticks*JIFFIES)"

.PP
The \fBto_ms(ticks)\fP macro converts from native clock ticks to milliseconds\&. 
.PP
Definition at line 81 of file timer\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef void*( caribou_timer_callback_fn)(void *thread, struct \fB_caribou_timer_t\fP *timer, void *arg)"

.PP
Definition at line 47 of file timer\&.h\&.
.SS "typedef struct \fB_caribou_timer_t\fP  \fBcaribou_timer_t\fP"

.PP
The caribou_timer_t structure defines the data structure used by CARIBOU to maintain timers and sleep periods\&. 
.PP
\fBNote:\fP
.RS 4
The structure elements should not be manipulated by the application program, and are subject to change in future releases\&. 
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "\fBcaribou_timer_t\fP* caribou_timer_create (\fBcaribou_timer_callback_fn\fP *timerfn, void *arg, uint8_tflags)"

.PP
Instantiate a new timer on the heap memory, and associate it with the current thread\&.  timerfn The timer callback function\&. 
.PP
\fBParameters:\fP
.RS 4
\fIarg\fP Arguments to pass to the callback function 
.br
\fIflags\fP Timer flags 
.RE
.PP
\fBReturns:\fP
.RS 4
A pointer to the newly allocated caribou_timer_t* structure instance, or NULL if a problem was encountered\&. 
.RE
.PP

.PP
Definition at line 152 of file timer\&.c\&.
.SS "void caribou_timer_delete (void *thread, \fBcaribou_timer_t\fP *timer)"

.PP
Dispose of a timer instance associated with a thread\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthread\fP The thread associated with the timer\&. 
.br
\fItimer\fP A pointer to the timer instance\&. 
.RE
.PP

.PP
Definition at line 236 of file timer\&.c\&.
.SS "void caribou_timer_delete_all (void *thread)"

.PP
Dispose of all timer instances associated with a thread\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthread\fP The thread which references the timers to be disposed\&. 
.RE
.PP

.PP
Definition at line 248 of file timer\&.c\&.
.SS "\fBbool\fP caribou_timer_expired (\fBcaribou_timer_t\fP *timer)"

.PP
The \fBcaribou_timer_expired()\fP function is used to determine if a timer has expired\&. 
.PP
\fBParameters:\fP
.RS 4
\fItime\fP A pointer to a previously initialized caribou_timer_t instance\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
true if the timer has expired, or false if the timer has yet to expire\&. 
.RE
.PP

.PP
Definition at line 45 of file timer\&.c\&.
.SS "\fBcaribou_timer_t\fP* caribou_timer_init (\fBcaribou_timer_t\fP *timer, \fBcaribou_timer_callback_fn\fP *timerfn, void *arg, uint8_tflags)"

.PP
\fBParameters:\fP
.RS 4
\fItmer\fP A pointer to the timer  timerfn The timer callback function 
.br
\fIarg\fP Arguments to pass to the callback function 
.br
\fIflags\fP Timer flags 
.RE
.PP
\fBReturns:\fP
.RS 4
A pointer to the timer or NULL if a problem was encountered\&. 
.RE
.PP

.PP
Definition at line 174 of file timer\&.c\&.
.SS "\fBcaribou_timer_t\fP* caribou_timer_reset (\fBcaribou_timer_t\fP *timer)"

.PP
Reset the period of the specified timer\&. 
.PP
\fBParameters:\fP
.RS 4
\fItimer\fP A pointer to a previously initialized timer\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A pointer to the timer instance\&. 
.RE
.PP

.PP
Definition at line 223 of file timer\&.c\&.
.SS "\fBcaribou_timer_t\fP* caribou_timer_set (\fBcaribou_timer_t\fP *timer, uint32_tticks)"

.PP
Set the period of the specified timer\&. 
.PP
\fBParameters:\fP
.RS 4
\fItimer\fP A pointer to a previously initialized timer\&. 
.br
\fIticks\fP The number of ticks per period\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A pointer to the timer instance\&. 
.RE
.PP

.PP
Definition at line 209 of file timer\&.c\&.
.SS "\fBcaribou_tick_t\fP caribou_timer_ticks ()"

.PP
Definition at line 32 of file timer\&.c\&.
.SS "\fBbool\fP caribou_timer_ticks_timeout (\fBcaribou_tick_t\fPstart, \fBcaribou_tick_t\fPtimeout)"

.PP
Determine of the timeout period has expired in relationn to the start time\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstart\fP The time from which the timeout period should have started\&. 
.br
\fItimeout\fP The timeout period, TIMEOUT_INFINATE wait forever, TIMEOUT_IMMEDIATE, wait never\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
true if the timeout has expired\&. 
.RE
.PP

.PP
Definition at line 194 of file timer\&.c\&.
.SS "void caribou_timer_usec_delay (uint32_tusecs)"
FIXME microsecond delay 
.PP
Definition at line 312 of file timer\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for CARIBOU RTOS from the source code\&.
