.TH "src/kernel/thread.c" 3 "Thu Dec 29 2016" "Version 0.9" "CARIBOU RTOS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/kernel/thread.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <caribou/kernel/thread\&.h>\fP
.br
\fC#include <caribou/kernel/timer\&.h>\fP
.br
\fC#include <caribou/kernel/interrupt\&.h>\fP
.br
\fC#include <caribou/lib/queue\&.h>\fP
.br
\fC#include <caribou/lib/heap\&.h>\fP
.br
\fC#include <caribou/lib/string\&.h>\fP
.br
\fC#include <caribou/lib/errno\&.h>\fP
.br
\fC#include <chip/chip\&.h>\fP
.br
\fC#include <cpu/cpu\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBsystick_enter\fP()"
.br
.RI "\fIDefines the steps to run on entry to a systick ISR\&. \fP"
.ti -1c
.RI "#define \fBsystick_exit\fP()"
.br
.RI "\fIthe steps to run on exit from a systick ISR \fP"
.ti -1c
.RI "#define \fBpendsv_enter\fP()"
.br
.RI "\fIDefines the steps to run on entry to a pendsv ISR\&. \fP"
.ti -1c
.RI "#define \fBpendsv_exit\fP()"
.br
.RI "\fIthe steps to run on exit from a pendsv ISR \fP"
.ti -1c
.RI "#define \fBrunnable\fP(thread)   ((thread->state & \fBCARIBOU_THREAD_F_IDLE_MASK\fP) == 0)"
.br
.RI "\fIdetermine if the thread is in a runnable state \fP"
.ti -1c
.RI "#define \fBpreemptable\fP(thread)   (thread->lock==0)"
.br
.RI "\fIdetermine of the thread can be preempted at this time\&. \fP"
.ti -1c
.RI "#define \fBnextinqueue\fP(thread)   ( thread->next ? thread->next : caribou_state\&.queue )"
.br
.RI "\fIfind the next thread in the queue \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static void \fBruntimers\fP ()"
.br
.RI "\fIForward declaration for the private \fBruntimers()\fP function\&. \fP"
.ti -1c
.RI "static uint16_t \fBfault_clear\fP (void)"
.br
.RI "\fIClear the fault flags\&. The current thread is locked prior to setting the lags, and is unlocked after the flags have been set\&. \fP"
.ti -1c
.RI "static uint16_t \fBfault_set\fP (uint16_t flags)"
.br
.RI "\fISet a fault flag\&. The current thread is locked prior to setting the lags, and is unlocked after the flags have been set\&. \fP"
.ti -1c
.RI "uint16_t \fB_caribou_thread_fault_emit\fP (uint16_t flags)"
.br
.RI "\fIEmit a thread fault by calling the faultfn callback function\&. \fP"
.ti -1c
.RI "void \fBcaribou_thread_dump\fP ()"
.br
.ti -1c
.RI "static \fBcaribou_thread_t\fP * \fBnew_thread_node\fP (\fBcaribou_thread_t\fP *parent)"
.br
.RI "\fIAllocate and initialize a thread node\&. \fP"
.ti -1c
.RI "static void \fBdelete_thread_node\fP (\fBcaribou_thread_t\fP *node)"
.br
.RI "\fIDispose of a thread node\&. \fP"
.ti -1c
.RI "static \fBcaribou_thread_t\fP * \fBappend_thread_node\fP (\fBcaribou_thread_t\fP *node)"
.br
.RI "\fIAppend a thread node to the list\&. \fP"
.ti -1c
.RI "static \fBcaribou_thread_t\fP * \fBinsert_thread_node\fP (\fBcaribou_thread_t\fP *node, \fBcaribou_thread_t\fP *after)"
.br
.RI "\fIAppend a thread node to the list\&. \fP"
.ti -1c
.RI "static \fBcaribou_thread_t\fP * \fBremove_thread_node\fP (\fBcaribou_thread_t\fP *node)"
.br
.RI "\fIRemove a thread node from the list\&. \fP"
.ti -1c
.RI "static \fBcaribou_thread_t\fP * \fBfind_child_thread_node\fP (\fBcaribou_thread_t\fP *parent)"
.br
.RI "\fIlocate next child \fP"
.ti -1c
.RI "int \fBcaribou_thread_lock\fP (void)"
.br
.RI "\fILock the current thread such that it will not yield CPU time until such time that the thread is unlocked by \fBcaribou_thread_unlock()\fP\&. Needless to say this should generally be used sparingly\&. \fP"
.ti -1c
.RI "int \fBcaribou_thread_unlock\fP (void)"
.br
.RI "\fIUnlock a thread which has been previously been locked with \fBcaribou_thread_lock()\fP \fP"
.ti -1c
.RI "int \fBcaribou_thread_locked\fP (\fBcaribou_thread_t\fP *thread)"
.br
.RI "\fIDetermine of the current thread is locked? \fP"
.ti -1c
.RI "void \fBcaribou_thread_sleep\fP (\fBcaribou_thread_t\fP *thread, \fBcaribou_tick_t\fP ticks)"
.br
.ti -1c
.RI "void \fBcaribou_thread_sleep_current\fP (\fBcaribou_tick_t\fP ticks)"
.br
.ti -1c
.RI "void \fBcaribou_thread_wakeup\fP (\fBcaribou_thread_t\fP *thread)"
.br
.ti -1c
.RI "const char * \fBcaribou_thread_set_name\fP (\fBcaribou_thread_t\fP *thread, const char *name)"
.br
.RI "\fISet a pointer to the thread's name\&. \fP"
.ti -1c
.RI "const char * \fBcaribou_thread_name\fP (\fBcaribou_thread_t\fP *thread)"
.br
.RI "\fIreturn the thread name pointer \fP"
.ti -1c
.RI "uint64_t \fBcaribou_thread_runtime\fP (\fBcaribou_thread_t\fP *thread)"
.br
.RI "\fIreturn the thread's runtime in jiffies \fP"
.ti -1c
.RI "uint32_t \fBcaribou_thread_stacksize\fP (\fBcaribou_thread_t\fP *thread)"
.br
.RI "\fIreturn the thread's stack size in bytes\&. \fP"
.ti -1c
.RI "uint32_t \fBcaribou_thread_stackusage\fP (\fBcaribou_thread_t\fP *thread)"
.br
.RI "\fIreturn the task's stack usage in bytes\&. \fP"
.ti -1c
.RI "uint16_t \fBcaribou_thread_state\fP (\fBcaribou_thread_t\fP *thread)"
.br
.RI "\fIreturn the task's state \fP"
.ti -1c
.RI "\fBcaribou_thread_t\fP * \fBcaribou_thread_parent\fP (\fBcaribou_thread_t\fP *thread)"
.br
.RI "\fIreturn the parent thread \fP"
.ti -1c
.RI "void \fBcaribou_thread_wfi\fP ()"
.br
.RI "\fIA wrapper for the hardware 'Wait For Interrupt' function chip_wfi()\&. \fP"
.ti -1c
.RI "void \fBcaribou_thread_yield\fP (void)"
.br
.RI "\fIThe remainder of the scheduled time slots for the current thread are disposed and the next runnable thread in the queue is scheduled\&. \fP"
.ti -1c
.RI "void \fBcaribou_thread_terminate\fP (\fBcaribou_thread_t\fP *thread)"
.br
.RI "\fISchedules a thread to be terminate upon the next execution of the main thread idle loop\&. The thread's finish callback is executed, in which case the thread is responsible for releasing any resources it may have allocated\&. Thread timers will automatically be stopped and disposed\&. \fP"
.ti -1c
.RI "void \fBthread_finish\fP (void)"
.br
.RI "\fIGet here if a thread returns from it's run() function, wait to die\&. \fP"
.ti -1c
.RI "\fBcaribou_thread_t\fP * \fBcaribou_thread_create\fP (const char *name, void(*run)(void *), void(*finish)(void *), void *arg, void *stackaddr, int stack_size, int16_t priority)"
.br
.ti -1c
.RI "void \fBcaribou_thread_fault_set\fP (void *(*fn)(int, void *), void *arg)"
.br
.RI "\fIset the thread fault callback handler \fP"
.ti -1c
.RI "\fBcaribou_thread_t\fP * \fBcaribou_thread_root\fP (void)"
.br
.ti -1c
.RI "\fBcaribou_thread_t\fP * \fBcaribou_thread_current\fP (void)"
.br
.ti -1c
.RI "\fBcaribou_thread_t\fP * \fBcaribou_thread_first\fP (void)"
.br
.ti -1c
.RI "void * \fBcaribou_thread_current_arg\fP (void)"
.br
.RI "\fIreturn current thread arg \fP"
.ti -1c
.RI "void \fBcaribou_thread_set_priority\fP (\fBcaribou_thread_t\fP *thread, int16_t prio)"
.br
.RI "\fISet the priority of the current thread\&. \fP"
.ti -1c
.RI "int16_t \fBcaribou_thread_priority\fP (\fBcaribou_thread_t\fP *thread)"
.br
.ti -1c
.RI "\fBcaribou_thread_t\fP * \fBcaribou_thread_init\fP (int16_t priority)"
.br
.RI "\fIInitialize the thread system with priority of main thread, this creates the main 'caribou' thread\&. \fP"
.ti -1c
.RI "void \fBcaribou_thread_schedule\fP (\fBcaribou_thread_t\fP *thread)"
.br
.RI "\fISchedule a thread to run next\&. The specified thread will be queued to run on the next context switch\&. If it is desired to schedule the thread to run immediately, then follow the \fBcaribou_thread_schedule()\fP call with a call to \fBcaribou_thread_yield()\fP\&. \fP"
.ti -1c
.RI "\fB__attribute__\fP ((weak))"
.br
.RI "\fIMain thread idle time processing\&. This weakly liked function gets called during main (caribou) thread idle time\&. There is no guaranteed schedule, however, under normal circumstances, the main_idle() function should be called with a period of one millisecond\&. Normally the function over-ride resides in main\&.c/pp and must utilize 'C' linkage\&. \fP"
.ti -1c
.RI "static void \fBcheck_sp\fP (\fBcaribou_thread_t\fP *thread)"
.br
.ti -1c
.RI "void \fBcaribou_thread_once\fP ()"
.br
.RI "\fIwait for interrupt \fP"
.ti -1c
.RI "void \fBcaribou_thread_exec\fP ()"
.br
.RI "\fIEnter into the main thread execution loop\&. This function does not return\&. This function should be called once all other threads are created and started\&. This function has two callbacks board_idle() and main_idle()\&. \fP"
.ti -1c
.RI "static void \fB_swap_thread\fP ()"
.br
.RI "\fIPerforms the thread scheduling function\&. Currently a round-robin search for the next runnable\&. \fP"
.ti -1c
.RI "void \fB__attribute__\fP ((naked))"
.br
.RI "\fIIn the case where the current thread is preempted by \fBcaribou_thread_yield()\fP, then there is no jiffies counting, otherwise it's the same as the normal scheduler interrupt\&. If CARIBOU_LOW_STACK_TRAP is defined, stack overflow trapping is performed\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBcaribou_state_t\fP \fBcaribou_state\fP"
.br
.RI "\fIAn instance o the current thread state\&. \fP"
.ti -1c
.RI "uint32_t \fB__process_stack_base__\fP"
.br
.RI "\fIExternal reference to the process stack base, normally defined in the linker script\&. \fP"
.ti -1c
.RI "uint32_t \fB__process_stack_end__\fP"
.br
.RI "\fIExternal reference to the process stack end (top), normally defined in the linker script\&. \fP"
.ti -1c
.RI "uint32_t \fB__main_thread_stack_base__\fP"
.br
.RI "\fIExternal reference to the main thread stack base, normally defined in the linker script\&. \fP"
.ti -1c
.RI "uint32_t \fB__main_thread_stack_end__\fP"
.br
.RI "\fIExternal reference to the main thread stack base (top), normally defined in the linker script\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 

.PP
.PP
\fBAuthor:\fP
.RS 4
Mike Sharkey mike@pikeaero.com\&. 
.RE
.PP
\fBCopyright:\fP
.RS 4
© 2005-2013 by Pike Aerospace Research Corporation 
.PP
© 2014-2015 by Mike Sharkey
.RE
.PP
This file is part of CARIBOU RTOS CARIBOU RTOS is free software: you can redistribute it and/or modify it under the terms of the Beerware License Version 43\&. 'THE BEER-WARE LICENSE' (Revision 43): Mike Sharkey mike@pikeaero.com wrote this file\&. As long as you retain this notice you can do whatever you want with this stuff\&. If we meet some day, and you think this stuff is worth it, you can buy me a beer in return ~ Mike Sharkey 
.PP
Definition in file \fBthread\&.c\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define nextinqueue(thread)   ( thread->next ? thread->next : caribou_state\&.queue )"

.PP
find the next thread in the queue 
.PP
Definition at line 76 of file thread\&.c\&.
.SS "#define pendsv_enter()"
\fBValue:\fP
.PP
.nf
cpu_systick_enter();   \
        chip_pendsv_enter()
.fi
.PP
Defines the steps to run on entry to a pendsv ISR\&. 
.PP
Definition at line 47 of file thread\&.c\&.
.SS "#define pendsv_exit()"
\fBValue:\fP
.PP
.nf
chip_pendsv_exit();   \
        cpu_systick_exit()
.fi
.PP
the steps to run on exit from a pendsv ISR 
.PP
Definition at line 54 of file thread\&.c\&.
.SS "#define preemptable(thread)   (thread->lock==0)"

.PP
determine of the thread can be preempted at this time\&. 
.PP
Definition at line 74 of file thread\&.c\&.
.SS "#define runnable(thread)   ((thread->state & \fBCARIBOU_THREAD_F_IDLE_MASK\fP) == 0)"

.PP
determine if the thread is in a runnable state 
.PP
Definition at line 72 of file thread\&.c\&.
.SS "#define systick_enter()"
\fBValue:\fP
.PP
.nf
cpu_systick_enter();   \
        chip_systick_enter()
.fi
.PP
Defines the steps to run on entry to a systick ISR\&. 
.PP
Definition at line 33 of file thread\&.c\&.
.SS "#define systick_exit()"
\fBValue:\fP
.PP
.nf
chip_systick_exit(); \
        cpu_systick_exit()
.fi
.PP
the steps to run on exit from a systick ISR 
.PP
Definition at line 40 of file thread\&.c\&.
.SH "Function Documentation"
.PP 
.SS "__attribute__ ((weak))"

.PP
Main thread idle time processing\&. This weakly liked function gets called during main (caribou) thread idle time\&. There is no guaranteed schedule, however, under normal circumstances, the main_idle() function should be called with a period of one millisecond\&. Normally the function over-ride resides in main\&.c/pp and must utilize 'C' linkage\&. Main thread idle time processing\&. This weakly liked function gets called during main (caribou) thread idle time\&. There is no guaranteed schedule, however, under normal circumstances, the board_idle() function should be called with a period of one millisecond\&. Normally the function over-ride resides in board\&.c/pp and must utilize 'C' linkage\&. 
.PP
Definition at line 642 of file thread\&.c\&.
.SS "void __attribute__ ((naked))"

.PP
In the case where the current thread is preempted by \fBcaribou_thread_yield()\fP, then there is no jiffies counting, otherwise it's the same as the normal scheduler interrupt\&. If CARIBOU_LOW_STACK_TRAP is defined, stack overflow trapping is performed\&. Entry point for handing a scheduler timer interrupt\&. Determines which thread is the next runnable on the queue, and switches context\&. The jiffies counter is incremented and a jiffy is added to the current thread's total run time\&. If CARIBOU_LOW_STACK_TRAP is defined, stack overflow trapping is performed\&. 
.PP
Definition at line 777 of file thread\&.c\&.
.SS "uint16_t _caribou_thread_fault_emit (uint16_tflags)"

.PP
Emit a thread fault by calling the faultfn callback function\&. 
.PP
Definition at line 106 of file thread\&.c\&.
.SS "static void _swap_thread ()\fC [inline]\fP, \fC [static]\fP"

.PP
Performs the thread scheduling function\&. Currently a round-robin search for the next runnable\&. 
.PP
Definition at line 720 of file thread\&.c\&.
.SS "static \fBcaribou_thread_t\fP* append_thread_node (\fBcaribou_thread_t\fP *node)\fC [static]\fP"

.PP
Append a thread node to the list\&. 
.PP
Definition at line 181 of file thread\&.c\&.
.SS "\fBcaribou_thread_t\fP* caribou_thread_create (const char *name, void(*)(void *)run, void(*)(void *)finish, void *arg, void *stackaddr, intstack_size, int16_tpriority)"
Create a new instance of a CARIBOU thread\&. 
.PP
\fBParameters:\fP
.RS 4
\fIname\fP The ascii name of the thread\&. This pointer must remain valid for the life span of the thread instance\&. 
.br
\fIrun\fP A Pointer to the entry point function of the thread\&. Note the entry point function must accept a void* pointer even if it is not used\&. 
.br
\fIfinish\fP A function which is called up thread termination\&. 
.br
\fIarg\fP An argument pointer which is passed to the thread entry point function run\&. 
.br
\fIstackaddr\fP A pointer to bottom of the program stack associated with this thread\&. 
.br
\fIstack_size\fP The size of the stack belonging to this thread\&. 
.br
\fIpriority\fP The priority of the thread\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A pointer to the newly created thread or NULL if something failed\&. 
.RE
.PP

.PP
Definition at line 473 of file thread\&.c\&.
.SS "\fBcaribou_thread_t\fP* caribou_thread_current (void)"

.PP
\fBReturns:\fP
.RS 4
A pointer to the currently running thread structure\&. 
.RE
.PP

.PP
Definition at line 553 of file thread\&.c\&.
.SS "void* caribou_thread_current_arg (void)"

.PP
return current thread arg 
.PP
Definition at line 567 of file thread\&.c\&.
.SS "void caribou_thread_dump ()"

.PP
Definition at line 135 of file thread\&.c\&.
.SS "void caribou_thread_exec ()"

.PP
Enter into the main thread execution loop\&. This function does not return\&. This function should be called once all other threads are created and started\&. This function has two callbacks board_idle() and main_idle()\&. main thread exec loop - used by CARIBOU 
.PP
Definition at line 707 of file thread\&.c\&.
.SS "void caribou_thread_fault_set (void *(*)(int, void *)fn, void *arg)"

.PP
set the thread fault callback handler 
.PP
Definition at line 535 of file thread\&.c\&.
.SS "\fBcaribou_thread_t\fP* caribou_thread_first (void)"

.PP
\fBReturns:\fP
.RS 4
first thread\&. 
.RE
.PP

.PP
Definition at line 561 of file thread\&.c\&.
.SS "\fBcaribou_thread_t\fP* caribou_thread_init (int16_tpriority)"

.PP
Initialize the thread system with priority of main thread, this creates the main 'caribou' thread\&. 
.PP
Definition at line 599 of file thread\&.c\&.
.SS "int caribou_thread_lock (void)"

.PP
Lock the current thread such that it will not yield CPU time until such time that the thread is unlocked by \fBcaribou_thread_unlock()\fP\&. Needless to say this should generally be used sparingly\&. 
.PP
\fBReturns:\fP
.RS 4
The current state of the lock\&. 
.RE
.PP

.PP
Definition at line 265 of file thread\&.c\&.
.SS "int caribou_thread_locked (\fBcaribou_thread_t\fP *thread)"

.PP
Determine of the current thread is locked? 
.PP
\fBReturns:\fP
.RS 4
The current state of the lock\&. 
.RE
.PP

.PP
Definition at line 308 of file thread\&.c\&.
.SS "const char* caribou_thread_name (\fBcaribou_thread_t\fP *thread)"

.PP
return the thread name pointer 
.PP
Definition at line 373 of file thread\&.c\&.
.SS "void caribou_thread_once ()"

.PP
wait for interrupt 
.PP
Definition at line 681 of file thread\&.c\&.
.SS "\fBcaribou_thread_t\fP* caribou_thread_parent (\fBcaribou_thread_t\fP *thread)"

.PP
return the parent thread 
.PP
Definition at line 403 of file thread\&.c\&.
.SS "int16_t caribou_thread_priority (\fBcaribou_thread_t\fP *thread)"

.PP
\fBReturns:\fP
.RS 4
The thread priority of the current thread\&. 
.RE
.PP

.PP
Definition at line 590 of file thread\&.c\&.
.SS "\fBcaribou_thread_t\fP* caribou_thread_root (void)"

.PP
\fBReturns:\fP
.RS 4
a pointer to the root thread, normally the 'caribou' thread\&. 
.RE
.PP

.PP
Definition at line 545 of file thread\&.c\&.
.SS "uint64_t caribou_thread_runtime (\fBcaribou_thread_t\fP *thread)"

.PP
return the thread's runtime in jiffies 
.PP
Definition at line 379 of file thread\&.c\&.
.SS "void caribou_thread_schedule (\fBcaribou_thread_t\fP *thread)"

.PP
Schedule a thread to run next\&. The specified thread will be queued to run on the next context switch\&. If it is desired to schedule the thread to run immediately, then follow the \fBcaribou_thread_schedule()\fP call with a call to \fBcaribou_thread_yield()\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthread\fP The thread to schedule to run next\&. 
.RE
.PP

.PP
Definition at line 616 of file thread\&.c\&.
.SS "const char* caribou_thread_set_name (\fBcaribou_thread_t\fP *thread, const char *name)"

.PP
Set a pointer to the thread's name\&. 
.PP
Definition at line 366 of file thread\&.c\&.
.SS "void caribou_thread_set_priority (\fBcaribou_thread_t\fP *thread, int16_tprio)"

.PP
Set the priority of the current thread\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthread\fP A pointer to the target thread\&. 
.br
\fIprio\fP The priority to assign to the thread in terms of additional scheduling slots assigned to the thread\&. For instance, 0 means to perform a switch the thread upon the next context switch interrupt, and 1 means to add one additional context cycle to the thread's run-time\&. 
.RE
.PP

.PP
Definition at line 580 of file thread\&.c\&.
.SS "void caribou_thread_sleep (\fBcaribou_thread_t\fP *thread, \fBcaribou_tick_t\fPticks)"
Sleep another thread for a number of clock ticks\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthread\fP The thread to put to sleep\&. 
.br
\fIticks\fP Number of jiffies to sleep for\&. A zero (0) value indicates forever or until woken up the \fBcaribou_thread_wakeup()\fP function\&. 
.RE
.PP

.PP
Definition at line 326 of file thread\&.c\&.
.SS "void caribou_thread_sleep_current (\fBcaribou_tick_t\fPticks)"
Sleep the current thread for a number of clock ticks\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthread\fP The thread to put to sleep\&. A zero (0) value indicates forever or until woken up the \fBcaribou_thread_wakeup()\fP function\&. 
.br
\fIticks\fP Number of jiffies to sleep for\&. Forever or until woken up if ticks==0\&. 
.RE
.PP

.PP
Definition at line 351 of file thread\&.c\&.
.SS "uint32_t caribou_thread_stacksize (\fBcaribou_thread_t\fP *thread)"

.PP
return the thread's stack size in bytes\&. 
.PP
Definition at line 385 of file thread\&.c\&.
.SS "uint32_t caribou_thread_stackusage (\fBcaribou_thread_t\fP *thread)"

.PP
return the task's stack usage in bytes\&. 
.PP
Definition at line 391 of file thread\&.c\&.
.SS "uint16_t caribou_thread_state (\fBcaribou_thread_t\fP *thread)"

.PP
return the task's state 
.PP
Definition at line 397 of file thread\&.c\&.
.SS "void caribou_thread_terminate (\fBcaribou_thread_t\fP *thread)"

.PP
Schedules a thread to be terminate upon the next execution of the main thread idle loop\&. The thread's finish callback is executed, in which case the thread is responsible for releasing any resources it may have allocated\&. Thread timers will automatically be stopped and disposed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthread\fP The thread to be scheduled for termination\&. 
.RE
.PP

.PP
Definition at line 432 of file thread\&.c\&.
.SS "int caribou_thread_unlock (void)"

.PP
Unlock a thread which has been previously been locked with \fBcaribou_thread_lock()\fP 
.PP
\fBReturns:\fP
.RS 4
The current state of the lock\&. 
.RE
.PP

.PP
Definition at line 282 of file thread\&.c\&.
.SS "void caribou_thread_wakeup (\fBcaribou_thread_t\fP *thread)"
Wake a thread previously put to sleep with \fBcaribou_thread_sleep()\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthread\fP The thread to wake up\&. 
.RE
.PP

.PP
Definition at line 358 of file thread\&.c\&.
.SS "void caribou_thread_wfi ()"

.PP
A wrapper for the hardware 'Wait For Interrupt' function chip_wfi()\&. for debugging, dump the thread list to stdout 
.PP
Definition at line 411 of file thread\&.c\&.
.SS "void caribou_thread_yield (void)"

.PP
The remainder of the scheduled time slots for the current thread are disposed and the next runnable thread in the queue is scheduled\&. 
.PP
Definition at line 420 of file thread\&.c\&.
.SS "static void check_sp (\fBcaribou_thread_t\fP *thread)\fC [static]\fP"

.PP
Definition at line 656 of file thread\&.c\&.
.SS "static void delete_thread_node (\fBcaribou_thread_t\fP *node)\fC [static]\fP"

.PP
Dispose of a thread node\&. 
.PP
Definition at line 173 of file thread\&.c\&.
.SS "static uint16_t fault_clear (void)\fC [static]\fP"

.PP
Clear the fault flags\&. The current thread is locked prior to setting the lags, and is unlocked after the flags have been set\&. 
.PP
Definition at line 82 of file thread\&.c\&.
.SS "static uint16_t fault_set (uint16_tflags)\fC [static]\fP"

.PP
Set a fault flag\&. The current thread is locked prior to setting the lags, and is unlocked after the flags have been set\&. 
.PP
Definition at line 94 of file thread\&.c\&.
.SS "static \fBcaribou_thread_t\fP* find_child_thread_node (\fBcaribou_thread_t\fP *parent)\fC [static]\fP"

.PP
locate next child 
.PP
Definition at line 242 of file thread\&.c\&.
.SS "static \fBcaribou_thread_t\fP* insert_thread_node (\fBcaribou_thread_t\fP *node, \fBcaribou_thread_t\fP *after)\fC [static]\fP"

.PP
Append a thread node to the list\&. 
.PP
Definition at line 205 of file thread\&.c\&.
.SS "static \fBcaribou_thread_t\fP* new_thread_node (\fBcaribou_thread_t\fP *parent)\fC [static]\fP"

.PP
Allocate and initialize a thread node\&. parent A pointer to the parent thread node, or NULL\&. 
.PP
\fBNote:\fP
.RS 4
THREAD_FAULT_ALLOC_FAILURE is emitted upon allocation failure\&. 
.RE
.PP

.PP
Definition at line 155 of file thread\&.c\&.
.SS "static \fBcaribou_thread_t\fP* remove_thread_node (\fBcaribou_thread_t\fP *node)\fC [static]\fP"

.PP
Remove a thread node from the list\&. 
.PP
Definition at line 218 of file thread\&.c\&.
.SS "static void runtimers ()\fC [static]\fP"

.PP
Forward declaration for the private \fBruntimers()\fP function\&. 
.SS "void thread_finish (void)"

.PP
Get here if a thread returns from it's run() function, wait to die\&. 
.PP
Definition at line 450 of file thread\&.c\&.
.SH "Variable Documentation"
.PP 
.SS "uint32_t __main_thread_stack_base__"

.PP
External reference to the main thread stack base, normally defined in the linker script\&. 
.SS "uint32_t __main_thread_stack_end__"

.PP
External reference to the main thread stack base (top), normally defined in the linker script\&. 
.SS "uint32_t __process_stack_base__"

.PP
External reference to the process stack base, normally defined in the linker script\&. 
.SS "uint32_t __process_stack_end__"

.PP
External reference to the process stack end (top), normally defined in the linker script\&. 
.SS "\fBcaribou_state_t\fP caribou_state"

.PP
An instance o the current thread state\&. An instance o the current thread state\&. 
.PP
Definition at line 29 of file thread\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for CARIBOU RTOS from the source code\&.
