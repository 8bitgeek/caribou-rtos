/******************************************************************************
* Copyright Â© 2005-2012 by Pike Aerospace Research Corporation
* All Rights Reserved
*
*   This file is part of CARIBOU RTOS
*
*   CARIBOU RTOS is free software: you can redistribute it and/or modify
*   it under the terms of the Beerware License Version 43.
*
* ----------------------------------------------------------------------------
* "THE BEER-WARE LICENSE" (Revision 43):
* <mike@pikeaero.com> wrote this file. As long as you retain this notice you
* can do whatever you want with this stuff. If we meet some day, and you think
* this stuff is worth it, you can buy me a beer in return ~ Mike Sharkey
* ----------------------------------------------------------------------------
******************************************************************************/

#include <caribou/kernel/timer.h>
#include <caribou/kernel/thread.h>
#include <caribou/kernel/interrupt.h>
#include <caribou/lib/heap.h>
#include <chip/chip.h>
#include <cpu/cpu.h>

static caribou_tick_t	_caribou_tail_jiffies=0;
extern caribou_tick_t	_caribou_jiffies;
extern uint16_t			_caribou_thread_fault_emit(uint16_t flags);

/*******************************************************************************
*							 TIMER
*******************************************************************************/

/**
 * @brief The caribou_timer_expired() function is used to determine
 * if a timer has expired.
 * @param time A pointer to a previously initialized caribou_timer_t 
 * instance.
 * @return true if the timer has expired, or false if the timer has yet to expire.
 */
bool caribou_timer_expired(caribou_timer_t* timer)
{
	return (timer->ticks==0);
}


// dispose of a thread node
static void delete_timer_node(caribou_timer_t* node)
{
	if ( node->flags & CARIBOU_TIMER_F_DYNAMIC )
		free(node);
}

// append a thread node to the list
static caribou_timer_t* append_timer_node(caribou_thread_t* thread, caribou_timer_t* node)
{
	int state = caribou_lock();
	register caribou_timer_t* last = thread->timer;
	if ( last != NULL )
	{
		while ( last->next != NULL )
		{
			last = last->next;
		}
		last->next = node;
		node->prev = last;
	}
	else
	{
		thread->timer = node;
		node->prev=NULL;
		node->next=NULL;
	}
	caribou_lock_set(state);
	return node;
}

// remove a timer node from the list
static caribou_timer_t* remove_timer_node(caribou_thread_t* thread, caribou_timer_t* node)
{
	int state = caribou_lock();
	if ( node == thread->timer )
	{
		thread->timer = node->next;
		if ( thread->timer != NULL )
		{
			thread->timer->prev = NULL;
		}
	}
	else
	{
		if ( node->prev != NULL ) node->prev->next = node->next;
		if ( node->next != NULL ) node->next->prev = node->prev;
		node->next=NULL;
		node->prev=NULL;
	}
	caribou_lock_set(state);
	return node;
}

/**
 * @brief Allocate a thread node on the heap, and initialize it
 */
static caribou_timer_t* new_timer_node(void* (*timerfn)(void*,void*), void* fnarg )
{
	caribou_timer_t* node = (caribou_timer_t*)malloc(sizeof(caribou_timer_t));
	if ( node )
	{
		memset(node,0,sizeof(caribou_timer_t));
		node->timerfn = timerfn;
		node->fnarg = fnarg;
	}
	else
	{
		_caribou_thread_fault_emit(THREAD_FAULT_ALLOC_FAILURE);
	}
	return node;
}


/**
 * @brief Instantiate a new timer on the heap memory, and associate it with the current thread. 
 * @patam timerfn The timer callback function
 * @param arg Arguments to pass to the callback function
 * @param flags Timer flags
 * @return A pointer to the newly allocated caribou_timer_t* structure instance,
 * or NULL if a problem was encountered.
 */
caribou_timer_t* caribou_timer_create( caribou_timer_callback_fn* timerfn, void* arg, uint8_t flags )
{
	caribou_thread_t* thread = caribou_thread_current();
	caribou_timer_t* timer = new_timer_node(timerfn,arg);
	if ( timer )
	{
		timer->flags = flags | CARIBOU_TIMER_F_DYNAMIC;
        timer->timerfn = timerfn;
        timer->fnarg = arg;
		append_timer_node(thread,timer);
	}
	return timer;
}

/**
 * @brief 
 * @param tmer A pointer to the timer
 * @patam timerfn The timer callback function
 * @param arg Arguments to pass to the callback function
 * @param flags Timer flags
 * @return A pointer to the timer or NULL if a problem was encountered.
 */
caribou_timer_t* caribou_timer_init( caribou_timer_t* timer, caribou_timer_callback_fn* timerfn, void* arg, uint8_t flags )
{
	caribou_thread_t* thread = caribou_thread_current();
	if ( timer )
	{
        memset(timer,0,sizeof(caribou_timer_t));
		timer->flags = flags & ~CARIBOU_TIMER_F_DYNAMIC;
        timer->timerfn = timerfn;
        timer->fnarg = arg;
		append_timer_node(thread,timer);
	}
	return timer;
}

/**
 * @brief Determine of the timeout period has expired in relationn to the start time.
 * @param start The time from which the timeout period should have started.
 * @param timeout The timeout period, TIMEOUT_INFINATE wait forever, TIMEOUT_IMMEDIATE, wait never.
 * @return true if the timeout has expired.
 */
bool caribou_timer_ticks_timeout(caribou_tick_t start, caribou_tick_t timeout)
{
	bool rc=false;
	if ( TIMEOUT_INFINITE != timeout )
	{
		if ( TIMEOUT_IMMEDIATE != timeout )
		{
			rc = ((caribou_timer_ticks()-start) >= timeout);
		}
		else
		{
			rc=true;
		}
	}
	return rc; 
}

/**
 * @brief Set the period of the specified timer.
 * @param timer A pointer to a previously initialized timer.
 * @param ticks The number of ticks per period.
 * @return A pointer to the timer instance.
 */
caribou_timer_t* caribou_timer_set( caribou_timer_t* timer, uint32_t ticks )
{
	int state = caribou_lock();
	timer->ticks = ticks;
	timer->reloadticks = ticks;
	caribou_lock_set(state);
	return timer;
}

/**
 * @brief Reset the period of the specified timer.
 * @param timer A pointer to a previously initialized timer.
 * @return A pointer to the timer instance.
 */
caribou_timer_t* caribou_timer_reset( caribou_timer_t* timer )
{
	int state = caribou_lock();
	timer->ticks = timer->reloadticks;
	caribou_lock_set(state);
	return timer;
}

/**
 * @brief Dispose of a timer instance associated with a thread.
 * @param thread The thread associated with the timer.
 * @param timer A pointer to the timer instance.
 */
void caribou_timer_delete( void* thread, caribou_timer_t* timer )
{
	int state = caribou_lock();
	caribou_timer_set(timer,0);
	remove_timer_node((caribou_thread_t*)thread, timer);
	delete_timer_node(timer);
	caribou_lock_set(state);
}
/**
 * @brief Dispose of all timer instances associated with a thread.
 * @param thread The thread which references the timers to be disposed.
 */
void caribou_timer_delete_all( void* thread )
{
	while ( ((caribou_thread_t*)thread)->timer )
		caribou_timer_delete( (caribou_thread_t*)thread, ((caribou_thread_t*)thread)->timer );
}

/**
 * @return The number of microseconds per native clock tick (JIFFIES).
 */
int caribou_timer_period(void)
{
	return JIFFIES;
}

/**
 * @return The number of native clock ticks (JIFFIES) per millisecond.
 */
caribou_tick_t caribou_timer_ticks(void)
{
	return _caribou_jiffies;
}

/**
** @brief Expire sleep timers and timer timers
** @param thread The subject of the timer and sleep expiry.
** @param delta_jiffies The number of jiffies elapsed since the last timer expiry run.
** @return number timers expired.
*/
static int expire_timer(caribou_thread_t* thread, caribou_timer_t* timer, int delta_jiffies)
{
	int rc=0;
    if ( timer->ticks )
    {
        timer->ticks = (timer->ticks>=delta_jiffies)?timer->ticks-delta_jiffies:0;
        if ( !timer->ticks )
        {
            if ( timer->timerfn )
            {
                timer->timerfn(thread,timer,timer->fnarg);
            }
            if ( !(timer->flags & CARIBOU_TIMER_F_ONESHOT) )
            {
                timer->ticks = timer->reloadticks;
            }
            ++rc;
        }
    }
	return rc;
}

/**
 * @brief Used by CARIBOU to process timers during the main thread idle loop.
 * @return number of timers expired
 */
int caribou_timer_idle(caribou_thread_t* thread)
{
	int rc;
	int delta_jiffies;
	int state = chip_systick_irq_disable();
	delta_jiffies=(_caribou_jiffies-_caribou_tail_jiffies);
	if ( delta_jiffies )
	{
        caribou_thread_t* next;
        caribou_timer_t* timer;
        _caribou_tail_jiffies = _caribou_jiffies;
        for(; thread!=NULL; thread=next)
        {
            /** expire timers...*/
            for(timer=((caribou_thread_t*)thread)->timer; timer!=NULL; timer = timer->next)
            {
                rc += expire_timer(thread,timer,delta_jiffies);
            }
            next = thread->next; /* capture the next in case we terminate this thread */
        }
	}
	chip_systick_irq_set(state);
	return rc;
}

/**
 * FIXME microsecond delay 
 */
void caribou_timer_usec_delay(uint32_t usecs)
{
	chip_usec_delay(usecs);
}

